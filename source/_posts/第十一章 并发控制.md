---
title:  数据库原理第十一章 并发控制
date: 2022-12-20 18:08:55
categories: 数据库系统原理
tags: [数据库]
---

（终于写完了= =

数据库中可能有多个用户同时执行事务，为了保证这些事务不会互相影响，需要进行并发控制来保障数据的**一致性和隔离性**。

数据库对于多个事务的执行又如下方式：

1. 串行执行：T1->T2->...，一个一个排队完成
2. 交叉并发：在事务间来回切换
3. 同时并发：多处理机系统，真正的并发

在本章中，1作为我们的判断标杆，是个并发处理策略是否是合格的需要看其结果是否能与某种串行执行一致。2是我们主要的讨论情况。

## 并发控制概述

下面三类并发操作可能导致数据的不一致性：

- 丢失修改：两个事务同时写入一个数据，导致先写入的这个结果丢失

  ![image-20221220103455549](/images/oneplusnameless/image-20221220103455549.png)

- 不可重复读：T1读取数据以后，T2更新数据，导致T1无法再现前一次结果

  具体根据**T2更新的类型**又分为三种情况：

  - T1读->T2**修改**->T1再次读，得到了不一样的值
  - T1读->T2**删除**->T1再次读，读不到某些数据
  - T1读->T2**插入**->T1再次读，多读了某些数据

  后两者又叫**幻读**

- 读“脏”数据：T1修改了某些数据，T2读了这些数据，但是T1最终因为某些原因**ROLLBACK**了，T2读的这些数据处在一个不正确的状态

总的来说，可以总结为这个表：

![image-20221220104143739](/images/oneplusnameless/image-20221220104143739.png)

## 封锁（Locking）

对一个数据对象操作之前添加锁，限制其他事务对其操作，分为：

- 排它锁（Exclusive Locks），又叫X锁、写锁

  ​	施加排它锁以后，其他事务**不能写也不能读**

- 共享锁（Share Locks），又叫S锁、读锁

  ​	施加共享锁以后，其他事务**可以读但是不能写**

锁相容矩阵如下：

![image-20221220113829540](/images/oneplusnameless/image-20221220113829540.png)

## 封锁协议

封锁协议，就是对于事务在什么时候加锁、释放锁的规则。

典型的封锁协议是**三级协议**，随着等级升高，避免并发错误的能力越强，当然，数据库的并发性能也会降低。

### 一级封锁协议

一级封锁协议只包含写锁：

事务修改数据R之前必须加X锁，等到事务结束才释放

由于其只有X锁，所以**只能防止丢失修改，不能防止不可重复读和脏数据**

### 二级封锁协议

在一级封锁协议的基础上，二级封锁协议增加了读锁：

事务T在读取数据R之前需要加S锁，在读取完毕之后释放

在一级协议的基础上，二级封锁协议添加了S锁，只不过S锁的持续时间很短，所以**只能预防读脏数据，而不能够预防不可重复读**

关于为什么读不到脏数据：

当一个事务修改R的时候，为其上了X锁，所以在其COMMIT或者ROLLBACK之前，别的事物都上不了S锁，自然也就不能读没有COMMIT的R

### 三级封锁协议

在一级协议的基础上，三级封锁不仅加了读锁，还将读锁释放的时间也推迟到了事务结束

即：事务T在读取数据R之前需要加S锁，事务结束释放

三级封锁协议可以**防止丢失修改、读脏数据和不可重复度三种情况**

## 活锁和死锁

在操作的资源调度中，也学过类似的概念

### 活锁

所谓活锁，并不是真的锁，而是调度政策导致某个事物**无限等待**的情况

避免活锁很简单，一般采用**先来先服务FCFS**调度策略

### 死锁

在OS中已经了解过，死锁产生的条件是：

- 请求互斥的共享资源
- 占有的资源不可被剥夺
- 持续占有并等待
- 相互循环等待

#### 死锁的预防

死锁的预防就是要**破坏死锁产生的必要条件**，有如下方法：

- 一次封锁法：一次性把事务需要的数据全部加锁
  - 但是这样会导致系统的并发度很低
  - 而且很难一次确定需要用到哪些数据
- 顺序封锁法：上锁必须有个公共顺序，前面的数据没上、后面的数据就不能上
  - 这个公共顺序的维护很难
  - 难以强制按照规定顺序加锁

总结：上面两种方法都是cjb，数据库的死锁问题不像OS，应该重在判断并解除而不是预防。

#### 死锁的诊断和解除

死锁的判断主要有超时法和等待图法

- 超时法：设定一个等待时限，如果事务等待超过这个时间就认为死锁了
  - 缺点：数据库事务运行时间各不一样，差别很大，时间设置很难
- 等待图法：节点是事务，有向边T1->T2表示T1正在等待T2释放某个锁。如果在等待图中发现存在回路，就表示系统中出现了死锁。

出现死锁以后，解除方法比较简单：选择代价最小的事务撤销即可

## 并发调度的可串行性

之前说过，串行调度虽然实用性不高，但是可以作为并发调度的一个准则来说

### 可串行化调度

如果一个并发调度算法的结果和**某一种**（串行也可以排列组合）串行运行的结果是一致的，就称之为可串行化

### 冲突可串行化

这是一种更严格的概念

**冲突**：指一对**连续**动作，满足：**交换顺序**以后，涉及的事务中至少有一个**事务行为改变**

冲突的情况：

- 同一事务：任何一对连续操作都是冲突的
- 不同事务对同一元素的写
- 不同事务对同一元素的一读一写

不冲突的情况：

- 不同事务对同一元素的读
- 不同事务对不同元素操作

**冲突可串行化：**指一个调度，可以只进行一系列不冲突动作的交换来转化为串行调度

## 两段锁协议

指一个事务分为上锁（扩展阶段）和释放锁（收缩阶段）两个阶段，一旦开始释放锁，就不允许上锁了

**两段锁协议可以保证调度是可串行化的**

但是两段锁协议的扩展阶段也不是一次性上完所有锁，不能够预防死锁

## 封锁的粒度

封锁的对象可以是逻辑单元（属性值、元组、关系、索引等）、也可以是物理单元（页、物理记录）

封锁粒度越大，系统开销越小，并发度也小。

### 多粒度封锁

对于不同事务，封锁粒度不一致，需要处理大量元组的事务就封锁关系、需处理少量元组的事务就只需要封锁相应元组

### 多粒度树

用树结构表示数据库的逻辑单元，根是数据库，叶是最小的数据粒度。

常用的是**三级粒度树**：

![image-20221220164444763](/images/oneplusnameless/image-20221220164444763.png)

对于一个数据对象节点，封锁有两种：

- 显式封锁：在这个节点加锁
- 隐式封锁：在上级节点加了锁，这个节点自然也被锁了

所以在上锁的时候，除了检查本节点，还要检查其所有祖先节点和子节点：

- 本对象当然不能够有锁
- 上级节点也不能够有锁，因为这会导致本节点有隐式锁
- 下级节点也不能够被上锁，因为本节点会对下级节点上隐式锁

所以这个过程其实是很麻烦的，要检查所有上下级节点

为了这个检查过程的方便，就引入了意向锁

### 意向锁Intent Lock

当给一个节点上锁的时候，要对其**所有上节点加意向锁**，这样就不必要在加锁的时候检查大量下节点了

由于锁分为共享锁和排它锁，所以意向锁也有分类：

- 意向共享锁（IS锁）：说明这个节点的某子节点加了S锁
- 意向排它锁（IX锁）：说明这个节点的某子节点加了X锁
- 共享意向排它锁（SIX锁）：SIX=S+IX，即这个节点自身加了S锁，某子节点加了X锁

一个5*5的锁相容矩阵就来了：

![image-20221220171115002](/images/oneplusnameless/image-20221220171115002.png)

锁的强度：

![image-20221220172108647](/images/oneplusnameless/image-20221220172108647.png)

**申请封锁应该自上而下、释放封锁应该自下而上**

## 小结

本章首先抛出的交叉并发可能导致的问题：丢失修改、不可重复读、读脏数据

数据库是围绕锁来进行并发控制的

首先介绍了最基础的锁：共享锁和排它锁。

有了基本的两种锁还不行，需要统一规定一个上锁的策略，根据上锁策略严格程度分为三级封锁协议：

- 一级：写之前上排它锁，事务结束释放
- 二级：一级 + 读之前上共享锁，读完释放
- 三级：一级 + 读之前上共享锁，事务结束释放



有了锁，就有等待，进而可能出现活锁和死锁：

- 活锁指因为调度问题，某个事物等待非常久
- 死锁指进入了一个死循环

死锁的条件是

- 请求互斥的共享资源
- 占有的资源不可被剥夺
- 持续占有并等待
- 相互循环等待

死锁的预防手段有：一次封锁和顺序封锁法

DB的死锁处理一般倾向于诊断后解除而不是预防

死锁的诊断方法有：超时法和等待图法

死锁的解除比较简单：选择代价小的UNDO



为了判断一个调度的正确性，可以按照其结果是否与串行结果中的一个一致，这样的调度叫做可串行化调度

冲突可串行化则是更加严苛的概念，表示一个调度在一系列非冲突操作对的对换以后，可以变换成串行调度

两段锁协议是保障可串行化的方法，但是其不能预防死锁



最后还介绍了多粒度封锁，可以依据事务的不同，决定封锁的级别，多粒度封锁一般用多粒度树表示

上级节点封锁会给下级节点上隐式锁，在给一个节点上锁的时候，还需要判断上级有没有给其上隐式锁，以及本节点需要对下级节点上显式锁，这会导致本节点无法对下级节点上隐式锁

上述的检查过程是非常麻烦的，尤其是检查数量繁多的下级节点，所以引入了意向锁，表示被上意向锁的下级节点中有被上锁的

根据锁类型的不同，意向锁又分为IS/IX/SIX锁，再加上S/X锁，五种锁之间有了一个5*5的锁相容矩阵
