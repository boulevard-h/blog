---
title:  数据库原理第九章 查询优化
date: 2022-12-18 22:56:39
categories: 数据库系统原理
tags: [数据库]
mathjax: true
---

本章大体介绍了一个查询语句是怎么在DBMS中运作的，并且给出了几种经典情况的代数、物理优化方法。

## DBMS的查询处理

DBMS的查询处理分为四个阶段：

1. 查询分析

   - 词法分析：分析SQL符号
   - 语法分析：语法检查

2. 查询检查

   - 语义分析
   - 符号转换
   - 安全性、完整性检查

   查询检查后、会构建好查询树，针对查询树来进行代数优化

3. 查询优化

   - 代数优化
   - 物理优化

   优化以后，就可以生成一个查询执行计划

4. 查询执行

   - 代码生成器会按照上一步的查询执行计划生成代码来执行

### 查询算法的实例

#### 选择操作的实现

- **全表扫描**
  1. 按照物理次序入读数据块到内存
  2. 检查元组，满足则输出
  3. 重复直到读完内存为止
- **索引扫描**
  1. 使用索引得到符合条件的元组指针
  2. 通过制作检索

#### 连接操作的实现

- **嵌套循环算法nested loop join**

  ​	for 外层循环: (for 内层循环)

- **排序-合并算法sort-merge join**

  1. 两个表都对连接字段排序
  2. 也是两个循环，但是内层循环不需要每次都从0开始

- **索引连接算法index join**

​		一个表索引、遍历另一个表，直接根据索引连接

- **Hash Join**

  1. 划分阶段：选择元组较少的表，Hash到内存中对应的bucket
  2. 试探（连接）阶段：hash另一个表中的元组，找到bucket中对应的连接输出

  适用场景：一个表小（可以Hash散列到内存中）、一个表较大，只支持等值连接

## 关系数据库系统的查询优化

RDBMS的查询路径是透明的，RDBMS可以考虑比程序员更多、更复杂的优化并从中选取代价最小的

**查询的代价 =** **I/O代价（最主要的）**+ CPU代价 + 内存代价 + 通信代价

下面用一个例子来阐述查询优化：

``` sql
SELECT Student.Sname
FROM Student, SC
WHERE Student.Sno=SC.Sno AND SC.Cno='2';
```

假设Student表有1000条记录、SC表有10000条记录，其中有50条选2号课程的记录。

一个块可以装10条Student或者100条SC、内存中可以存放5块Student、1块SC

- **Q1 = **$\pi_{\text {Sname }}\left(\sigma_{\text {Student.Sno }=\text { SC.Sno } \and \text { SC.Cno }='2'}(\text { Student } \times \text { SC })\right)$

  也就是先连接然后投影，下面分析其效率

  - 每次读取5块student表，然后遍历一次SC，一共$\frac{1000}{5\times10}\times \frac{10000}{100}=2000$块，Student表本身需要读$\frac{1000}{10}$块
  - 连接以后的元组有1000×10000个，还是假设一个块可以装10条连接以后的元组，那么需要写入1000000块到中间文件
  - 选择的时候，又要读入这1000000块，投影输出满足条件的50条

- **Q2 = **$\pi_{\text {Sname }}\left(\sigma_{\text {SC.Cno }='2'}(\text { Student } \bowtie \text { SC })\right)$

  - 执行自然连接，需要读取的还是2000+100=2100块
  - 连接以后的元组就大大减少了，为10000个，所以只要写入1000块到中间文件
  - 读入这1000块，投影输出满足条件的50条

- **Q3 = **$\pi_{\text {Sname }}\left(\text { Student } \bowtie \sigma_{\text {SC.Cno }='2'}(\mathrm{SC})\right)$

  - 读入SC，需要读入10000/100=100块，然后选择出其中的50条、不需要中间文件
  - 与Student自然连接，需要读入100块
  - 投影输出结果

优化到Q3以后，I/O就只要读写200块了。

**对于Q3的继续优化：**

- 如果在SC.Cno有索引，那么就不需要读入SC，而是读入索引（占大概3-4块）
- 如果Student.Sno也有索引，那么连接时也不要读入所有的记录

在上述过程中：从Q1优化为等价的关系代数表达式Q3，就是一种**代数优化**；上面的两个索引就是**物理优化**。

## 代数优化

### 关系代数表达式的等价变换规则

比较多， 不要死记硬背，能够分析改变以后会不会影响结果就行

1. 连接和笛卡尔积两边可交换
2. 多重连接、笛卡尔积的结合律
3. 投影串接：两次投影可以合并
4. 选择串接：两次选择可以合并
5. 投影与选择交换：若选择不涉及投影属性，可以先投影再选择
6. 选择与笛卡尔积交换
7. 选择与并/差/自然连接可以分配
8. 投影与并/笛卡尔积可以分配，但是对差没有

### 查询树的启发式优化

前面说过，DBMS会把SQL转化成查询树结构，查询树的叶子节点是关系、非叶子节点是关系运算符，执行顺序是从叶子到根。

**典型的几条启发式规则：**

- **选择运算尽可能先做**（最重要、可以很大量级的减少中间元组数量）
- 同时选择和投影：选择到元组输出的时候顺便做个投影
- 投影与其前后的双目运算结合
- 将 先笛卡尔积再选择 转化为 连接
- 找出公共子表达式：重复出现、元组不多的子表达式可以写入中间文件

**利用规则得到一种启发式算法：**

1. 将$\sigma _{F_1 \and ...\and F_n}(E)$转化为$\sigma_{F_1}(...(\sigma_{F_n}(E)))$

   起初我在想，本来合并了选择条件，扫描表的次数变少了，为什么又要拆开呢？

   实际上，多个条件并在一起的判断时间开销会很大，而单个单个执行，其实第一次得到的结果就减少了很多、然后再执行一个又减少很多，实际遍历并不多。

2. 对于选择，尽量移动到叶端

3. 对于投影，尽量移动到叶端

4. 合并投影和附近其他运算

5. 得到语法树的内节点分组：双目运算和其所有祖先为一组、如果后代所有节点都是单目的，也并入

​	![image-20221218221623376](/images/DBSNote/image-20221218221623376.png)



## 物理优化

选择高效的算法和存取路径

物理优化算法主要分为两类：基于规则的启发式优化、基于代价估算的优化

一般是两者结合，启发式的找出若干方案，然后估算代价找出最优的

### 基于启发式规则的存取路径选择优化

#### 选择操作的启发式规则

- 小关系直接扫描
- 大关系
  - ”主码=？“：一般主码会索引
  - ”非主属性=？“：结果比例较小可以索引，比例较大直接扫描
  - 非等值：结果比例较小可以索引，比例较大直接扫描
  - and连接多个条件：
    - 有组合索引用组合索引
    - 有一般索引可以求交
    - 其他情况使用全表扫描
  - or连接多个条件：一般直接扫描

#### 连接操作的启发式规则

- 两个表都已经排序：sort-merge join
- 在一个表索引：index join
- 一个表比较小一个表比较大：hash join
- 如果使用nested loop join，外层循环应该选择较小的表

### 基于代价的优化

DBMS对于一些信息进行了统计，比如：

- 对于基本表
  - 元组长度、个数
- 对于列
  - 值个数
  - 最大最小值
  - 是否索引
  - 值分布
- 对索引
  - 索引层数
  - 不同索引值个数
- ...

根据这些信息，可以对算法得代价估算（数学期望），然后取最小的

## 小结

（这一章说是不作为重点，只考概念，但是概念也有够多了...

要了解DBMS是怎么去优化查询语句的，首先要知道是怎么处理的查询：首先分析词法语法、然后进行安全性完整性等检查、然后转化为查询树来进行代数&物理优化、最后生成代码执行

然后介绍了基础的选择、连接操作实现

对于优化，举了一个例子，指出了其中的代数优化和物理优化的步骤

对于代数优化的详细叙述，主要介绍了启发式优化：最重要的是先做选择运算，另外，投影可以尽量和其他运算合并、避免笛卡尔积、找出公共子表达式等

这里还介绍了语法树内节点分组的概念

物理优化方面，并用启发式和代价估算两种优化

选择算法的启发式物理优化，可以根据是否索引、结果占比、条件类型等具体判断

连接算法的启发式物理优化，其实在之前连接操作的实现部分已经涉及到了，四大连接算法有各自的适用情况

而基于代价的物理优化，是基于DBMS掌握的一些统计信息来估算的